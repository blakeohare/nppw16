import GFX;
import Math;
import Random;

class PowerupDrop {
	field id = null;
	field type;
	
	constructor(type) { 
		this.type = type;
	}
}

const BIKE_SPEED = 6;

class PlayScene {
	static field GOOD_HEALTH_COLOR = [255, 255, 255];
	static field POOR_HEALTH_COLOR = [255, 128, 128];
	
	field startArgs;
	field updateCounter = 0;
	field context;
	field flags = 'M';
	field next = this;
	field id;
	field hasAtmosphere;
	field bg;
	field stars;
	field runCounter;
	field runCounterValidFor;
	field cols;
	field rows;
	field upper;
	field lower;
	field side;
	field lazor_cooldown = 0;
	field tiles;
	field doorSwaps;
	field cameraX = 0;
	field cameraY = 0;
	field player;
	field sprites;
	field overlayTriggers;
	field special;
	field shooting;
	
	constructor(map, startCol, startRow, context) {
		this.startArgs = [map, startCol, startRow];
		
		this.context = context;
		levelname = map.split('.')[0];
		this.id = levelname;
		if (!map.endsWith('.map'))
			map += '.map';
		mapParser = new MapParser(map);
		map = mapParser.parse();
		
		this.hasAtmosphere = context.volcanoA && context.volcanoB && context.volcanoC;

		this.bg = getBackground(levelname);
		stars = [];
		for (i = 1; i <= 5; ++i) {
			stars.add(ImageLibrary.get('tiles/background/stars' + i + '.png'));
		}
		stars.concat([null] * 10);
		stars *= 3;
		stars.shuffle();
		this.stars = stars;
		this.runCounter = 0;
		this.runCounterValidFor = ':P';
		
		this.cols = map.width;
		this.rows = map.height;
		this.upper = map.upper;
		this.lower = map.lower;
		this.side = map.side;
		
		this.lazor_cooldown = 0;
		
		this.tiles = makeGrid(this.cols, this.rows);
		
		this.doorSwaps = map.doorswaps;
		
		doorTiles = [];
		ladderTiles = {};
		lowerdoors = [];
		for (y = this.rows - 1; y >= 0; --y) {
			for (x = 0; x < this.cols; ++x) {
				
				t = makeTile(this.lower[x][y], this.upper[x][y], x, y);
				this.tiles[x][y] = t;
				if (t.isDoor) {
					doorTiles.add([x + '|' + y, t]);
					if (this.side && y + 1 < this.rows) {
						// add the tile below the door to the potential door tiles
						// the door list from the map parser will check for the tile below a door iff it's a tall door and is 
						// expecting to find it in this list. If not, then this gets safely ignored
						doorTiles.add([x + '|' + (y + 1), this.tiles[x][y + 1]]);
					}
				}
				if (t.isLadder) {
					ladderTiles[x + '|' + y] = [x, y];
				}
			}
		}
		
		for (lk : ladderTiles.keys()) {
			coord = ladderTiles[lk];
			x = coord[0];
			y = coord[1];
			if (y > 0) {
				if (ladderTiles.get(x + "|" + (y - 1), null) == null) {
					this.tiles[x][y].isTop = true;
				}
			}
		}
		doorLookup = {};
		for (door : map.doors) {
			xys = [[door.sx, door.sy]];
			if (this.side) {
				xys.add([door.sx, door.sy + 1]);
			}
			for (xy : xys) {
				doorLookup[xy[0] + '|' + xy[1]] = door;
			}
		}
		
		for (doorTile : doorTiles) {
			dk = doorTile[0];
			door = doorLookup.get(dk, null);
			if (door != null) {
				doorTile[1].door = door;
				doorTile[1].collisions = [];
				doorTile[1].solid = false;
			}
		}
		
		this.cameraX = 0;
		this.cameraY = 0;
		
		this.player = new Sprite('player_' + (this.side ? 'side' : 'over'), startCol * 16 + 8, startRow * 16 + 7);
		this.sprites = [this.player];
		
		if (levelname == 'bike_level') {
			this.player.bikemode = true;
			this.player.floats = true;
		}
		
		for (enemy : map.enemies) {
			sprite = new Sprite(enemy.id, enemy.col * 16 + 8, enemy.row * 16 + 8);
			sprite.isEnemy = true;
			this.sprites.add(sprite);
		}
		
		this.overlayTriggers = map.overlayTriggers;
		
		for (powerup : map.powerups) {
			puid = powerup.id;
			if (!context.powerupsTaken.get(puid, false)) {
				powerupSprite = new Sprite('powerup', powerup.col * 16 + 8, powerup.row * 16 + 7);
				powerupSprite.powerupInfo = powerup;
				this.sprites.add(powerupSprite);
			}
		}
		
		this.special = getSpecialLevelStuff(levelname, this);
		for (special : this.special) {
			if (special.hasPostInit) {
				special.postInit();
			}
		}
	}
	
	function playersTile(offsetX = 0, offsetY = 0) {
		if (this.player == null) return null;
		p = this.player;
		tx = Math.floor(p.modelX / 16) + offsetX;
		ty = Math.floor(p.modelY / 16) + offsetY;
		if (tx >= 0 && ty >= 0 && tx < this.cols && ty < this.rows) {
			return this.tiles[tx][ty];
		}
		return null;
	}
	
	function processInput(events, pressed) {
		frozen = false;
		for (s : this.special) {
			if (s.freeze) {
				frozen = true;
			}
		}
		
		this.shooting = this.lazor_cooldown > 0;
		
		pause = false;
		
		if (!frozen) {
			if (this.side) {
				dx = 0;
				dy = 0;
				running = false;
				if (this.context.gravity) {
					if (pressed['B'] && !this.player.cling) {
						running = true;
						v = 5;
					} else {
						v = 3;
					}
				} else {
					v = 2.5;
				}
				
				if (this.player.bikemode) {
					v = 2.0;
				}
				
				if (pressed['left']) {
					dx = -v;
					if (running && this.runCounterValidFor == 'left') {
						this.runCounter++;
					} else {
						this.runCounter = 0;
						this.runCounterValidFor = 'left';
					}
				} else if (pressed['right']) {
					dx = v;
					if (running && this.runCounterValidFor == 'right') {
						this.runCounter++;
					} else {
						this.runCounter = 0;
						this.runCounterValidFor = 'right';
					}
				} else {
					this.runCounter = 0;
					this.runCounterValidFor = 'nothing';
				}
					
				
				if (pressed['up']) {
					if (this.player.bikemode) {
						dy = -v;
					}
					
					pt = this.playersTile();
					if (pt != null && pt.isLadder) {
						this.player.cling = true;
						//this.player.onGround = false;
						this.player.ladderDY = -2;
					}
				} else if (pressed['down']) {
					if (this.player.bikemode) {
						dy = v;
					}
					
					pt = this.playersTile();
					if (pt != null && pt.isLadder) {
						this.player.ladderDY = 2;
					} else {
						pt = this.playersTile(0, 1);
						if (pt != null && pt.isLadder) {
							this.player.modelY += 8;
							this.player.ladderDY = 2;
							this.player.cling = true;
						}
					}
				}
				
				if (this.player != null) {
					if (this.player.bikemode)
						dx += BIKE_SPEED;
					this.player.dx = dx;
					this.player.dy = dy;
				}
				
				for (event : events) {
					if (event.action == 'A') {
						if (event.down) {
							pt = this.playersTile();
							if (this.player.onGround || this.player.cling || (pt != null && pt.isWater)) {
								this.player.onGround = false;
								this.player.cling = false;
								this.player.ladderDY = 0;
								if (pt.isWater) {
									this.player.vy += WATER_JUMPING_VY;
									playNoise('swim');
								} else {
									this.player.vy = JUMPING_VY;
									if (this.runCounter > 5 && this.context.gravity)
										this.player.vy = RUN_JUMPING_VY;
									playNoise('jump');
								}
							}
						} else {
							if (this.player.vy < 0) {
								this.player.vy = this.player.vy / 4.0; // maybe set to 0 instead?
							}
						}
					} else if (event.action == 'B' && event.down) {
						// SHOOT UR LAZOR PEW PEW!!!!1
						if (this.lazor_cooldown <= 0) { // && !this.player.cling) {
							p = this.player;
							lazorLeft = this.player.lastDirection == 'left';
							if (this.player.damageDir != null) {
								lazorLeft = this.player.damageDir == 'left';
							}
							lazorVX = 8;
							if (lazorLeft) {
								lazorVX = -8;
							}
							
							x = p.x + lazorVX;
							y = p.y - 8;
							
							if (p.spawns == null) {
								p.spawns = [];
							}
							
							playNoise('lazor');
							bullet = new Sprite('lazor', x, y);
							bullet.bvx = lazorVX;
							bullet.isBullet = true;
							bullet.ghost = true;
							bullet.floats = true;
							p.spawns.add(bullet);
							this.lazor_cooldown = 6;
						}
					} else if (event.action == 'start' && event.down) {
						this.next = new PauseScene(this);
					}
				}
			} else {
				v = 3;
				dx = 0;
				dy = 0;
				
				if (pressed['left']) {
					dx = -v;
				} else if (pressed['right']) {
					dx = v;
				}
					
				if (pressed['up']) {
					dy = -v;
				} else if (pressed['down']) {
					dy = v;
				}
				
				for (event : events) {
					if (event.action == 'start' && event.down) {
						this.next = new PauseScene(this);
					}
				}
				
				this.player.dx = dx;
				this.player.dy = dy;
			}
		}
	}
	
	function playMusic() {
		JukeBox.playSongForLevelMaybe(this.id);
	}
	
	function update() {
		this.updateCounter++;
		this.playMusic();
		
		playerX = this.player.modelX;
		playerY = this.player.modelY;
		sprites = this.sprites;
		this.lazor_cooldown--;
		newsprites = [];
		allBullets = [];
		for (i = 0; i < sprites.length; ++i) { // use an indexed loop instead of for loop since you're adding spawned sprites to the list while iterating through it.
			sprite = sprites[i];
			if (sprite != null && !sprite.dead) {
				sprite.update(this);
				if (sprite.isEnemy && this.player != null) {
					if (sprite.isCollision(this.player)) {
						this.playerHit();
					}
				}
				
				if (sprite.spawns != null) {
					for (spawn : sprite.spawns) {
						sprites.add(spawn);
					}
				}
				sprite.spawns = null;
				
				if (sprite.isBullet) {
					allBullets.add(sprite);
				}
			}
		}
		new_sprites = [];
		
		for (i = 0; i < sprites.length; ++i) {
			sprite = sprites[i];
			if (allBullets.length > 0 && sprite.type != 'bird1' && sprite.type != 'bird2') {
				if (sprite.isEnemy) {
					left = sprite.x - 8;
					right = sprite.x + 8;
					bottom = sprite.y + 8;
					top = bottom - sprite.height;
					
					for (j = 0; j < allBullets.length; ++j) {
						bullet = allBullets[j];
						bleft = bullet.x - 8;
						bright = bleft + 16;
						bbottom = bullet.y + 4;
						btop = bbottom - 8;
						
						// WAT?
						// I probably wrote this when I was about to collapse during PyWeek.
						if (bleft > right) { }
						else if (bright < left) { }
						else if (btop > bottom) { }
						else if (bbottom < top) { }
						else {
							sprite.dead = true;
							bullet.dead = true;
							switch (sprite.type) {
								case 'acorn':
								case 'acorntop':
								case 'byat':
								case 'moonsquid':
								case 'lavamonster':
									dropN = Random.randomInt(200);
									drop = null;
									if (dropN == 0) {
										drop = '1up';
									} else if (dropN < 8) {
										drop = 'life_big';
									} else if (dropN < 30) {
										drop = 'life_small';
									}
									
									if (drop != null) {
										// Can't do spawns since it'll get filtered out before then.
										powerup = new Sprite('powerup', sprite.x, sprite.y - 1);
										info = new PowerupDrop(drop);
										powerup.powerupInfo = info;
										new_sprites.add(powerup);
									}
									break;
									
								default:
									break;
							}
							poofType = 'poof_small';
							if (sprite.type == 'lavamonster') {
								poofType = 'poof_big';
							}
							
							poof = new Sprite(poofType, sprite.x, sprite.y);
							new_sprites.add(poof);
							playNoise('enemy_dies');
						}
					}
				}
			}
			
			if (!sprite.dead) {
				new_sprites.add(sprite);
			}
		}
		this.sprites = new_sprites;
		
		player_tx = Math.floor(this.player.modelX / 16);
		player_ty = Math.floor(this.player.modelY / 16);
		activeTile = this.tiles[player_tx][player_ty];
		if (activeTile.door != null) {
			door = activeTile.door;
			target = door.target;
			swaps = this.doorSwaps.get(target, null);
			
			if (swaps != null) {
				ctx = this.context;
				for (swap : swaps) {
					trigger = swap[0];
					if ((trigger == 'gravity' && ctx.gravity) ||
						(trigger == 'lavaA' && ctx.volcanoA) ||
						(trigger == 'lavaB' && ctx.volcanoB) ||
						(trigger == 'lavaC' && ctx.volcanoC) ||
						(trigger == 'waterA' && ctx.balloonA) ||
						(trigger == 'waterB' && ctx.balloonB) ||
						(trigger == 'waterC' && ctx.balloonC) ||
						(trigger == 'waterD' && ctx.balloonD)) {
						target = swap[1];
						break;
					}
				}
			}
			
			for (special : this.special) {
				if (special.hasDoorTrigger) {
					target = special.doorTrigger(target);
					break;
				}
			}
			
			if (target != null) {
				this.next = new PlayScene(target, door.tx, door.ty, this.context);
			}
		}
		
		pUp = this.playersTile(0, -1);
		pDown = this.playersTile(0, 0);
		
		if ((pUp != null && pUp.isSpike) || (pDown != null && pDown.isSpike)) {
			this.playerHit(3);
		}
		
		if ((pUp != null && pUp.isLava) || (pDown != null && pDown.isLava)) {
			this.next = new DeathOverrideScene(this, 'lava');
		}
		
		for (special : this.special) {
			if (special.hasUpdate) {
				special.update();
			}
		}
	}
	
	function playerHit(amount = 1) {
		if (this.player.blinkCounter < 0) {
			this.player.hit(this, amount);
		}
	}
	
	function isCollision(pLeft, pTop, pRight, pBottom) {
		if (pLeft < 0) return true;
		if (pTop < 0) return true;
		tLeft = Math.floor(pLeft / 16);
		tRight = (pRight == pLeft) ? tLeft : Math.floor(pRight / 16);
		tTop = Math.floor(pTop / 16);
		
		// potentially a bug
		// bottom row of sprite is technically top row of ground below. This intersection should be ignored.
		tBottom = Math.floor((pBottom - 3) / 16);
		
		if (tLeft < 0) return true;
		if (tTop < 0) return true;
		if (tRight >= this.cols) return true;
		if (tBottom >= this.rows) return true;
		
		y = tTop;
		for (y = tTop; y <= tBottom; ++y) {
			for (x = tLeft; x <= tRight; ++x) {
				if (this.tiles[x][y].solid) {
					return true;
				}
			}
		}
		return false;
	}
	
	function renderOverlay() {
		GFX.Draw.rectangle(0, 0, 256, 8, 0, 0, 0);
		ImageLibrary.get('misc/lives.png').draw(0, 0);
		drawText(255, 255, 255, 'x' + this.context.lives, 8, 0);
		
		x = 112;
		drawText(255, 255, 255, 'HEALTH', x, 0);
		
		x += 'HEALTH'.length * 8 + 8;
		
		health = this.context.lifemeter;
		color = PlayScene.GOOD_HEALTH_COLOR;
		if (health < 4) {
			color = PlayScene.POOR_HEALTH_COLOR;
		}
		for (i = 0; i < 5; ++i) {
			GFX.Draw.rectangle(x, 0, 16, 8, 128, 128, 128);
			if (health >= ((i + 1) * 2)) {
				GFX.Draw.rectangle(x + 1, 1, 14, 6, color[0], color[1], color[2]);
			} else if (health == 2 * i + 1) {
				GFX.Draw.rectangle(x + 1, 1, 7, 6, color[0], color[1], color[2]);
			}
			x += 16;
		}
		
		cat = this.context.getCurrentCountAndType();
		if (cat != null) {
			cnt = cat[1];
			
			if (cat[0] == 'W') {
				img = ImageLibrary.get('misc/water_icon.png');
				total = 4;
			} else {
				img = ImageLibrary.get('misc/volcano_icon.png');
				total = 3;
			}
							
			img.draw(48, 0);
			drawText(255, 255, 255, cnt + '/' + total, 56, 0);
		}
	}
	
	function render(rc) {
		if (this.bg == 'stars') {
			GFX.Draw.fill(0, 0, 0);
		} else if (this.bg == 'cave') {
		} else if (this.bg == 'volcano') {
		} else {
			GFX.Draw.fill(0, 0, 40); // sky
		}
		
		colStart = 0;
		colEnd = this.cols - 1;
		
		rowStart = 0;
		rowEnd = this.rows - 1;
		
		offsetX = -(this.player.x - 128);
		offsetY = -(this.player.y - 112);
		
		if (this.player.bikemode) {
			offsetX = -(this.updateCounter * BIKE_SPEED);
		}
		
		if (offsetX > 0) offsetX = 0;
		if (offsetY > 0) offsetY = 0;
		
		right = -(this.cols * 16 - 256);
		if (offsetX < right) offsetX = right;
		
		bottom = -(this.rows * 16 - 224);
		if (offsetY < bottom) offsetY = bottom;
		
		if (this.cols * 16 < 256)
			offsetX = (256 - this.cols * 16) / 2;
		if (this.rows * 16 < 224)
			offsetY = (224 - this.rows * 16) / 2;
		
		cave = ImageLibrary.get('tiles/background/cave.png');
		volcano_bg = ImageLibrary.get('tiles/background/volcano.png');
		starlen = this.stars.length;
		stars = this.stars;
		counter = 0;
		
		idealColStart = -floor(offsetX / 16) - 1;
		if (idealColStart > colStart)
			colStart = idealColStart;
		
		idealColEnd = colStart + 17;
		if (idealColEnd < colEnd)
			colEnd = idealColEnd;
		
		idealRowStart = -Math.floor(offsetY / 16) - 1;
		if (idealRowStart > rowStart)
			rowStart = idealRowStart;
		
		idealRowEnd = rowStart + 15;
		if (idealRowEnd < rowEnd)
			rowEnd = idealRowEnd;
		
		lavaLevel = 0;
		shake = 0;
		for (s : this.special) {
			lavaLevel = max(lavaLevel, s.lavaLevel);
			shake = max(shake, s.shakeScreen ? 3 : 0);
		}
		
		offsetX += shake;
		offsetY += shake / 3;
		
		lavaRowType = null;
		
		for (row = rowStart; row <= rowEnd; ++row) {
			fromBottom = rowEnd - row + 1;
			if (lavaLevel > 0) {
				if (fromBottom == lavaLevel) {
					lavaRowType = 'upper';
					lc = Math.floor((rc / 4) % 4) + 1;
					lu = ImageLibrary.get('tiles/fluids/lava' + lc + '.png');
				} else if (fromBottom < lavaLevel) {
					lavaRowType = 'inner' ;
					lu = ImageLibrary.get('tiles/fluids/lava.png');
				}
			}
			
			for (col = colStart; col <= colEnd; ++col) {
				counter++;
				x = col * 16 + offsetX;
				y = row * 16 + offsetY;
				if (this.bg == 'cave') {
					cave.draw(x, y);
				} else if (this.bg == 'volcano') {
					volcano_bg.draw(x, y);
					if (lavaRowType != null) {
						lu.draw(x, y);
					}
				} else if (this.bg == 'stars') {
					bgimg = stars[(col + this.rows * row + row * row) % starlen];
					if (bgimg != null) {
						bgimg.draw(x, y);
					}
				}
				
				for (template : this.tiles[col][row].templates) {
					template.getImage(rc).draw(x, y);
				}
			}
		}
		
		re_render = [];
		arc = rc / 4;
		for (sprite : this.sprites) {
			if (sprite != null && !sprite.dead) {
				sprite.render(this, offsetX, offsetY, arc);
				if (sprite.inBackground) {
					tx = sprite.x / 16;
					ty = (sprite.y + 8) / 16;
					re_render.add([tx, ty]);
					re_render.add([tx, ty - 1]);
					re_render.add([tx, ty - 2]);
				}
			}
		}
		
		for (rr : re_render) {
			col = rr[0];
			row = rr[1];
			if (row >= 0) {
				x = col * 16 + offsetX;
				y = row * 16 + offsetY;
				for (template : this.tiles[col][row].templates) {
					template.getImage(rc).draw(x, y);
				}
			}
		}
		
		for (s : this.special) {
			if (s.hasRender) {
				s.render(rc, offsetX, offsetY);
			}
		}
		
		this.renderOverlay();
	}
	
	function triggerDialog(id, slightDelay = false) {
		this.next = new DialogScene(this, id, slightDelay);
	}
}
