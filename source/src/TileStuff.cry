_tileStore = {};
function getTile(id) {
	if (_tileStore.length == 0) {
		initTileStore();
	}
	
	return _tileStore.get(id, null);
}

function initTileStore() {
	t = $resource_read_text('images/tiles/manifest.txt');
	
	for (line : t.split('\n')) {
		parts = line.split('#')[0].trim().split('\t');
		if (parts.length == 3) {
			id = parts[0].trim();
			flags = parts[1].trim();
			imagePaths = parts[2].trim().split(',');
			
			tile = new TileTemplate(id, flags, imagePaths);
			_tileStore[id] = tile;
		}
	}
}

class TileTemplate {
	constructor(id, flags, imagePaths) {
		this.id = id;
		this.solid = false;
		this.coveredA = false;
		this.coveredB = false;
		this.coveredC = false;
		this.coveredD = false;
		this.isDoor = false;
		this.isLadder = false;
		this.isTop = false;
		this.isWater = id == 'water' || id == 'watertop';
		this.isSpike = false;
		this.isLava = false;
		this.isIce = false;
		this.isBalloon = false;
		this.primaryBalloonOffset = null; // Location of top-middle balloon tile relative to this

		for (flag : flags) {
			switch (flag) {
				case 'x':
					this.solid = true;
					break;
				case 'A':
					this.coveredA = true;
					break;
				case 'B':
					this.coveredB = true;
					break;
				case 'C':
					this.coveredC = true;
					break;
				case 'D':
					this.coveredD = true;
					break;
				case 'r':
				case 'R':
					this.isDoor = true;
					break;
				case 'L':
					this.isLadder = true;
					break;
				case 'J':
					this.isTop = true;
					break;
				case 'S':
					this.isSpike = true;
					break;
				case 'V':
					this.isLava = true;
					break;
				case 'I':
					this.isIce = true;
					break;
				case 'o':
					this.isBalloon = true;
					bid = $parse_int(id[-1]);
					pOffset = [0, 0];
					if (bid == 1) {
						pOffset = [1, 0];
					} else if (bid == 3) {
						pOffset = [-1, 0];
					} else if (bid == 4) {
						pOffset= [1, -1];
					} else if (bid == 5) {
						pOffset = [0, -1];
					} else if (bid == 6) {
						pOffset = [-1, -1];
					}
					this.primaryBalloonOffset = pOffset;
					break;
				default:
					break;
			}
		}
					
		this.images = [];
		for (path : imagePaths) {
			this.images.add(IMAGES.get('tiles/' + path));
		}
		this.staticImage = null;
		if (this.images.length == 1) {
			this.staticImage = this.images[0];
		}
		this.imageCount = this.images.length;
	}
	
	function getImage(rc) {
		return this.staticImage ?? this.images[(rc / 4) % this.imageCount];
	}
}

function makeTile(lower, upper, col, row) {
	if (lower == null && upper == null) {
		return new Tile([], col, row);
	}
	
	if (lower == null) {
		return new Tile([upper], col, row);
	}
	
	if (upper == null) {
		return new Tile([lower], col, row);
	}
	
	return new Tile([lower, upper], col, row);
}

class Tile {
	constructor(templates, col, row) {
		this.col = col;
		this.row = row;
		this.originalTemplates = templates;
		this.templates = [];
		this.isDoor = false;
		this.isLadder = false;
		this.isTop = false;
		this.isLava = false;
		this.isWater = false;
		this.isIce = false;
		this.door = null;
		this.isSpike = false;
		this.isBalloon = false;
		this.primaryBalloonOffset = null;
		
		for (tile : templates) {
			if (tile != null) {
				this.templates.add(tile);
				if (tile.isDoor) this.isDoor = true;
				if (tile.isLadder) this.isLadder = true;
				if (tile.isTop) this.isTop = true;
				if (tile.isWater) this.isWater = true;
				if (tile.isSpike) this.isSpike = true;
				if (tile.isLava) this.isLava = true;
				if (tile.isIce) this.isIce = true;
				if (tile.isBalloon) {
					this.isBalloon = true;
					this.primaryBalloonOffset = tile.primaryBalloonOffset;
				}
			}
		}
		
		this.collisions = [];
		this.solid = false;
		
		coveredA = false;
		coveredB = false;
		coveredC = false;
		coveredD = false;
		
		for (t : this.templates) {
			if (t.solid) {
				coveredA = true;
				coveredB = true;
				coveredC = true;
				coveredD = true;
				this.solid = true;
			} else {
				coveredA = coveredA || t.coveredA;
				coveredB = coveredB || t.coveredB;
				coveredC = coveredC || t.coveredC;
				coveredD = coveredD || t.coveredD;
			}
		}
		
		leftCovered = coveredA && coveredC;
		rightCovered = coveredB && coveredD;
		topCovered = coveredA && coveredB;
		bottomCovered = coveredC && coveredD;
		
		if (leftCovered && rightCovered) {
			this.collisions.add([0, 0, 2, 2]);
			coveredA = false;
			coveredB = false;
			coveredC = false;
			coveredD = false;
			this.solid = true;
		} else if (leftCovered) {
			this.collisions.add([0, 0, 1, 2]);
			coveredA = false;
			coveredC = false;
		} else if (rightCovered) {
			this.collisions.add([1, 0, 1, 2]);
			coveredB = false;
			coveredD = false;
		} else if (topCovered) {
			this.collisions.add([0, 0, 2, 1]);
			coveredA = false;
			coveredB = false;
		} else if (bottomCovered) {
			this.collisions.add([0, 1, 2, 1]);
			coveredC = false;
			coveredD = false;
		}
		
		if (coveredA)
			this.collisions.add([0, 0, 1, 1]);
		if (coveredB)
			this.collisions.add([1, 0, 1, 1]);
		if (coveredC)
			this.collisions.add([0, 1, 1, 1]);
		if (coveredD)
			this.collisions.add([1, 1, 1, 1]);
		
		for (i = 0; i < this.collisions.length; ++i) {
			c = this.collisions[i];
			c[0] = c[0] * 8 + col * 16;
			c[1] = c[1] * 8 + row * 16;
			c[2] = c[0] + c[2] * 8;
			c[3] = c[1] + c[3] * 8;
			this.collisions[i] = c;
		}
		
		if (this.solid) {
			this.isTop = false;
			this.isLadder = false;
		}
	}
}
