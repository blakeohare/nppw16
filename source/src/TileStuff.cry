import Resources;

class TileStore {

	static field _tileStore = null;
	
	static function getTile(id) {
		if (TileStore._tileStore == null) {
			TileStore.initTileStore();
		}
		
		return TileStore._tileStore.get(id, null);
	}

	static function initTileStore() {
		t = Resources.readText('images/tiles/manifest.txt');
		TileStore._tileStore = {};
		
		for (line : t.split('\n')) {
			parts = line.split('#')[0].trim().split('\t');
			if (parts.length == 3) {
				id = parts[0].trim();
				flags = parts[1].trim();
				imagePaths = parts[2].trim().split(',');
				
				tile = new TileTemplate(id, flags, imagePaths);
				TileStore._tileStore[id] = tile;
			}
		}
	}
}

class TileTemplate {
	field id;
	field solid = false;
	field coveredA = false;
	field coveredB = false;
	field coveredC = false;
	field coveredD = false;
	field isDoor = false;
	field isLadder = false;
	field isTop = false;
	field isSpike = false;
	field isLava = false;
	field isIce = false;
	field isBalloon = false;
	field isWater;
	field primaryBalloonOffset = null; // Location of top-middle balloon tile relative to this
	field images = [];
	field staticImage = null;
	field imageCount;
	
	constructor(id, flags, imagePaths) {
		this.id = id;

		this.isWater = id == 'water' || id == 'watertop';
		for (flag : flags) {
			switch (flag) {
				case 'x':
					this.solid = true;
					break;
				case 'A':
					this.coveredA = true;
					break;
				case 'B':
					this.coveredB = true;
					break;
				case 'C':
					this.coveredC = true;
					break;
				case 'D':
					this.coveredD = true;
					break;
				case 'r':
				case 'R':
					this.isDoor = true;
					break;
				case 'L':
					this.isLadder = true;
					break;
				case 'J':
					this.isTop = true;
					break;
				case 'S':
					this.isSpike = true;
					break;
				case 'V':
					this.isLava = true;
					break;
				case 'I':
					this.isIce = true;
					break;
				case 'o':
					this.isBalloon = true;
					bid = Core.parseInt(id[-1]);
					pOffset = [0, 0];
					if (bid == 1) {
						pOffset = [1, 0];
					} else if (bid == 3) {
						pOffset = [-1, 0];
					} else if (bid == 4) {
						pOffset= [1, -1];
					} else if (bid == 5) {
						pOffset = [0, -1];
					} else if (bid == 6) {
						pOffset = [-1, -1];
					}
					this.primaryBalloonOffset = pOffset;
					break;
				default:
					break;
			}
		}
		for (path : imagePaths) {
			this.images.add(ImageLibrary.get('tiles/' + path));
		}
		if (this.images.length == 1) {
			this.staticImage = this.images[0];
		}
		this.imageCount = this.images.length;
	}
	
	function getImage(rc) {
		return this.staticImage ?? this.images[(rc / 4) % this.imageCount];
	}
}

function makeTile(lower, upper, col, row) {
	if (lower == null && upper == null) {
		return new Tile([], col, row);
	}
	
	if (lower == null) {
		return new Tile([upper], col, row);
	}
	
	if (upper == null) {
		return new Tile([lower], col, row);
	}
	
	return new Tile([lower, upper], col, row);
}

class Tile {
	field originalTemplates;
	field col;
	field row;
	field templates = [];
	field isDoor = false;
	field isLadder = false;
	field isTop = false;
	field isLava = false;
	field isWater = false;
	field isIce = false;
	field door = null;
	field isSpike = false;
	field isBalloon = false;
	field primaryBalloonOffset = null;
	field collisions = [];
	field solid = false;
		
	constructor(templates, col, row) {
		this.originalTemplates = templates;
		this.col = col;
		this.row = row;
		
		for (tile : templates) {
			if (tile != null) {
				this.templates.add(tile);
				if (tile.isDoor) this.isDoor = true;
				if (tile.isLadder) this.isLadder = true;
				if (tile.isTop) this.isTop = true;
				if (tile.isWater) this.isWater = true;
				if (tile.isSpike) this.isSpike = true;
				if (tile.isLava) this.isLava = true;
				if (tile.isIce) this.isIce = true;
				if (tile.isBalloon) {
					this.isBalloon = true;
					this.primaryBalloonOffset = tile.primaryBalloonOffset;
				}
			}
		}
		
		coveredA = false;
		coveredB = false;
		coveredC = false;
		coveredD = false;
		
		for (t : this.templates) {
			if (t.solid) {
				coveredA = true;
				coveredB = true;
				coveredC = true;
				coveredD = true;
				this.solid = true;
			} else {
				coveredA = coveredA || t.coveredA;
				coveredB = coveredB || t.coveredB;
				coveredC = coveredC || t.coveredC;
				coveredD = coveredD || t.coveredD;
			}
		}
		
		leftCovered = coveredA && coveredC;
		rightCovered = coveredB && coveredD;
		topCovered = coveredA && coveredB;
		bottomCovered = coveredC && coveredD;
		
		if (leftCovered && rightCovered) {
			this.collisions.add([0, 0, 2, 2]);
			coveredA = false;
			coveredB = false;
			coveredC = false;
			coveredD = false;
			this.solid = true;
		} else if (leftCovered) {
			this.collisions.add([0, 0, 1, 2]);
			coveredA = false;
			coveredC = false;
		} else if (rightCovered) {
			this.collisions.add([1, 0, 1, 2]);
			coveredB = false;
			coveredD = false;
		} else if (topCovered) {
			this.collisions.add([0, 0, 2, 1]);
			coveredA = false;
			coveredB = false;
		} else if (bottomCovered) {
			this.collisions.add([0, 1, 2, 1]);
			coveredC = false;
			coveredD = false;
		}
		
		if (coveredA)
			this.collisions.add([0, 0, 1, 1]);
		if (coveredB)
			this.collisions.add([1, 0, 1, 1]);
		if (coveredC)
			this.collisions.add([0, 1, 1, 1]);
		if (coveredD)
			this.collisions.add([1, 1, 1, 1]);
		
		for (i = 0; i < this.collisions.length; ++i) {
			c = this.collisions[i];
			c[0] = c[0] * 8 + col * 16;
			c[1] = c[1] * 8 + row * 16;
			c[2] = c[0] + c[2] * 8;
			c[3] = c[1] + c[3] * 8;
			this.collisions[i] = c;
		}
		
		if (this.solid) {
			this.isTop = false;
			this.isLadder = false;
		}
	}
}
