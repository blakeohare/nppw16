ACORN_SPEED = 1.5;
ACORN_DELAY_FOR_TOP_THROWING = 5 * 30;

class AcornAutomation {
	constructor(sprite) {
		this.sprite = sprite;
		this.countdown = $floor($random() * ACORN_DELAY_FOR_TOP_THROWING);
		this.mode = 'patrolling'; // patrolling | throwing | baldpatrolling
		this.top = null;
		this.walkingLeft = true;
	}
	
	function doStuff(scene) {
		this.countdown--;
		walk = false;
		if (this.mode == 'patrolling') {
			if (this.countdown <= 0) {
				this.mode = 'throwing';
				this.top = new Sprite('acorntop', this.sprite.x, this.sprite.y);
				this.top.acorntopdir = this.sprite.lastDirection;
				this.top.goLeft = this.top.acorntopdir == 'left';
				this.top.automation.setGoLeft(this.sprite.lastDirection == 'left');
				this.top.automation.setGoUp(this.sprite.y > scene.player.y);
				this.top.automation.body = this.sprite;
				this.top.deleteWhenOffScreen = true;
				this.top.ghost = true;
				this.top.floats = true;
				this.sprite.spawns = [this.top];
			} else {
				walk = true;
			}
		} else if (this.mode == 'throwing') {
			if (this.top.dead) {
				this.mode = 'baldpatrolling';
			} else if (this.top.automation.completed) {
				this.mode = 'patrolling';
				this.top.dead = true;
				this.countdown = ACORN_DELAY_FOR_TOP_THROWING;
			}
		} else if (this.mode == 'baldpatrolling') {
			walk = true;
		}
		
		if (walk) {
			if (this.sprite.collidedWall) {
				this.walkingLeft = !this.walkingLeft;
			}
			
			tiles = scene.tiles;
			cols = scene.cols;
			rows = scene.rows;
			dx = this.walkingLeft ? ACORN_SPEED : -ACORN_SPEED; // TODO: isn't this backwards?
			oldTileX = $floor(this.sprite.modelX / 16);
			newX = this.sprite.modelX + dx;
			oldTileY = $floor(this.sprite.modelY / 16);
			newTileX = $floor(newX / 16);
			if (newTileX < 0 || newTileX >= cols) {
				this.walkingLeft = !this.walkingLeft;
				return;
			}
			
			belowTileY = oldTileY + 1;
			
			if (newTileX == oldTileX) {
				this.sprite.dx = dx;
			} else {
				if (belowTileY < 0 || belowTileY >= rows) {
					// TODO: remove this? why was this if statement here?
				}
				t = tiles[newTileX][belowTileY];
				if (!t.solid && !t.isTop) {
					this.walkingLeft = !this.walkingLeft;
				} else {
					this.sprite.dx = dx;
				}
			}
			
			// TODO: walk back and forth, but don't fall off.
		}
	}
}
